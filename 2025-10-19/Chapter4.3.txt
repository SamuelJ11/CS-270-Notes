CHAPTER 4: PROCESSOR ARCHITECTURE

    III. Sequential Y86-64 Implementations

        • For the following discussion we will describe a processor called SEQ (sequential processor) which performs all the steps required to
          process one complete instruction per clock cycle

        A. Organizing Processing into Stages

            • Processing an instruction requires a number of operations:

                (1) Fetch: 
                    - reads the bytes of an instruction from memory, using the program counter (PC) as the memory address.
                    - from the instruction it extracts the two 4-bit portions (icode and ifun) of the instruction specifier byte, and possibly a 
                      register specifier byte and/or 8-byte constant word (valC).
                    - computes the address of the instruction (valP) following the current one in sequential order, giving
                      valP = %rip + sizeof(fetched instruction)

                (2) Decode:
                    - the decode stage figures out what data the instruction will operate on
                    - reads up to two operands (register values) from the register file giving values 'valA' and 'valB'

                (3) Execute:
                    - in this stage, the arithmetic logic unit (ALU) either (1) performs an operation specified by the instruction, (2) computes an 
                      effective address, or (3) increments or decrements the stack pointer.
                    - condition codes are possibly set
                    - the resulting value for the above computation is stored in 'valE'

                (4) Memory:
                    - read or write data to/from memory, with the value read being reffered to as 'valM'
                
                (5) Write back:
                    - writes up to two results to the register file

                (6) PC update:
                    - PC is set to the address of the next instruction

            • Using a simple and uniform structure is important when designing hardware, and having different instructions share as much hardware as 
              possible helps to greatly minimize complexity

            • Referencing figure 4.2 on page 385, we see that an integer operation OPq (addq, subq, andq, xorq) all have the same value of icode.

                - starting with the integer operations, we see that the fetch instruction simply requires two bytes (1 instruction specifier bytes and
                  1 register specifier byte), therefore valP is calculated as PC + 2

                - during the decode stage, the two operands (register values) are read
                
                - during the execute stage, the operands and the function specifier (ifun) are supplied to the ALU to return valE.  the instruction is modeled 
                  as valB OP valA (note the order of arguments which is consistent with the conventions of Y/x86-64)

                - nothing happens in the memory stage

                - ValE is written back to register rB in the write-back stage

                - PC is set to valP

            • Reference the figure below from page 415 to understand the other two instructions:   

                +-----------+--------------------------------+--------------------------+------------------------------+
                | Stage     | OPq rA, rB                     | rrmovq rA, rB            | irmovq V, rB                 |
                +===========+================================+==========================+==============================+
                | Fetch     | icode:ifun <- M₁[PC]           | icode:ifun <- M₁[PC]     | icode:ifun <- M₁[PC]         |
                |           | rA:rB <- M₁[PC+1]              | rA:rB <- M₁[PC+1]        | rA:rB <- M₁[PC+1]            |
                |           | valP <- PC + 2                 | valP <- PC + 2           | valC <- M₈[PC+2]             |
                |           |                                |                          | valP <- PC + 10              |
                +-----------+--------------------------------+--------------------------+------------------------------+
                | Decode    | valA <- R[rA]                  | valA <- R[rA]            |                              |
                |           | valB <- R[rB]                  |                          |                              |
                +-----------+--------------------------------+--------------------------+------------------------------+
                | Execute   | valE <- valB OP valA           | valE <- 0 + valA         | valE <- 0 + valC             |
                |           | Set CC                         |                          |                              |
                +-----------+--------------------------------+--------------------------+------------------------------+
                | Memory    |                                |                          |                              |
                +-----------+--------------------------------+--------------------------+------------------------------+
                | Write back| R[rB] <- valE                  | R[rB] <- valE            | R[rB] <- valE                |
                +-----------+--------------------------------+--------------------------+------------------------------+
                | PC update | PC <- valP                     | PC <- valP               | PC <- valP                   |
                +-----------+--------------------------------+--------------------------+------------------------------+

                - for the rrmovq instruction, since we do not need to fetch the second register operand we simply set the second ALU input to zero

                - for the irmovq, we need to fetch an 8-byte constant word as well as the 2 bytes for the instruction and register specifiers, causing
                  valP to have a value of PC + 10

                    -- this makes sense if you reference figure 4.2 on page 385 again, where it is noted that ID value 0xF is used in the instruction encodings 
                       when we need to indicate that no register should be accessed - here rB is that 0xF value

            • Memory instructions like rmmovq and mrmovq can be understood by referencing the table below

                +-----------+-----------------------------+-----------------------------+
                | Stage     | rmmovq rA, D(rB)            | mrmovq D(rB), rA            |
                +===========+=============================+=============================+
                | Fetch     | icode:ifun <- M₁[PC]        | icode:ifun <- M₁[PC]        |
                |           | rA:rB <- M₁[PC+1]           | rA:rB <- M₁[PC+1]           |
                |           | valC <- M₈[PC+2]            | valC <- M₈[PC+2]            |
                |           | valP <- PC + 10             | valP <- PC + 10             |
                +-----------+-----------------------------+-----------------------------+
                | Decode    | valA <- R[rA]               |                             |
                |           | valB <- R[rB]               | valB <- R[rB]               |
                +-----------+-----------------------------+-----------------------------+
                | Execute   | valE <- valB + valC         | valE <- valB + valC         |
                +-----------+-----------------------------+-----------------------------+
                | Memory    | M₈[valE] <- valA            | valM <- M₈[valE]            |
                +-----------+-----------------------------+-----------------------------+
                | Write back|                             | R[rA] <- valM               |
                +-----------+-----------------------------+-----------------------------+
                | PC update | PC <- valP                  | PC <- valP                  |
                +-----------+-----------------------------+-----------------------------+

                - both rmmovq and mrmovq use displacement addressing, which means the memory address they refer to isn’t just a plain register — it’s an offset from a base register

                    -- this offset is given by 'D', and that D (the displacement) is encoded in the instruction as an 8-byte constant (valC)

                - the memory instructions use the ALU to add valC to valB, giving the effective address (the sum of the displacement and the base register value) for the memory operation.

            • Next we have the 'pushq' and 'popq' instructions:
            
                +-----------+-----------------------------+-----------------------------+
                | Stage     | pushq rA                    | popq rA                     |
                +===========+=============================+=============================+
                | Fetch     | icode:ifun <- M₁[PC]        | icode:ifun <- M₁[PC]        |
                |           | rA:rB <- M₁[PC+1]           | rA:rB <- M₁[PC+1]           |
                |           |                             |                             |
                |           | valP <- PC + 2              | valP <- PC + 2              |
                +-----------+-----------------------------+-----------------------------+
                | Decode    | valA <- R[rA]               | valA <- R[%rsp]             |
                |           | valB <- R[%rsp]             | valB <- R[%rsp]             |
                +-----------+-----------------------------+-----------------------------+
                | Execute   | valE <- valB + (-8)         | valE <- valB + 8            |
                +-----------+-----------------------------+-----------------------------+
                | Memory    | M₈[valE] <- valA            | valM <- M₈[valA]            |
                +-----------+-----------------------------+-----------------------------+
                | Write back| R[%rsp] <- valE             | R[%rsp] <- valE             |
                |           |                             | R[rA] <- valM               |
                +-----------+-----------------------------+-----------------------------+
                | PC update | PC <- valP                  | PC <- valP                  |
                +-----------+-----------------------------+-----------------------------+

                - note that rB is a 'dummy' register referring to the 0xF value on page 385

                - In the execute stage, we use the ALU to decrement the stack pointer by 8, and this value is used for the memory write
                  address and is stored back to %rsp in the write-back stage.

                - In the memory stage, %rsp still holds its old value (it has not been decremented yet), this occurs in the write back stage

                - for the 'popq' instruction, we read two copies of the stack pointer in the decode stage:

                    -- this is clearly redundant but it matches the pattern used by other instructions, so the hardware design is more uniform:
                      
                      (1) allows the ALU to increment the stack pointer by 8 in the execute stage and 
                      
                      (2) use the unincremented value as the address for the memory operation

                - by using valA for memory read and valE for updating %rsp, we respect the convention of Y/x86-64 (read first, pop later) even though internally the ALU 
                  computes valE first in the execute stage
            
            • Finally we have the jump, call and return instructions:
         
                +-----------+-----------------------------+-----------------------------+-----------------------------+
                | Stage     | jXX Dest                    | call Dest                   | ret                         |
                +===========+=============================+=============================+=============================+
                | Fetch     | icode:ifun <- M₁[PC]        | icode:ifun <- M₁[PC]        | icode:ifun <- M₁[PC]        |
                |           | valC <- M₈[PC + 1]          | valC <- M₈[PC + 1]          |                             |
                |           | valP <- PC + 9              | valP <- PC + 9              | valP <- PC + 1              |
                +-----------+-----------------------------+-----------------------------+-----------------------------+
                | Decode    |                             |                             | valA <- R[%rsp]             |
                |           |                             | valB <- R[%rsp]             | valB <- R[%rsp]             |
                +-----------+-----------------------------+-----------------------------+-----------------------------+
                | Execute   | Cnd <- Cond(CC, ifun)       | valE <- valB + (-8)         | valE <- valB + 8            |
                +-----------+-----------------------------+-----------------------------+-----------------------------+
                | Memory    |                             | M₈[valE] <- valP            | valM <- M₈[valA]            |
                +-----------+-----------------------------+-----------------------------+-----------------------------+
                | Write back|                             | R[%rsp] <- valE             | R[%rsp] <- valE             |
                +-----------+-----------------------------+-----------------------------+-----------------------------+
                | PC update | PC <- Cnd ? valC : valP     | PC <- valC                  | PC <- valM                  |
                +-----------+-----------------------------+-----------------------------+-----------------------------+

                - note that none of the above instructions require a register specifier byte

                - in the execute stage of the jump instruction, we check the condition codes (CC) and the jump condition (ifun) to determine whether or not 
                  to take the branch, yielding a 1-bit signal Cnd

                - in the PC update stage, we test this flag and set the PC to valC (the jump target) if the flag is 1 and to valP (the address of the following instruction) 
                  if the flag is 0

                - Instructions 'call' and 'ret' bear some similarity to instructions 'pushq' and 'popq':

                    -- with instruction 'call', we push 'valP' (address of the instruction that follows the call instruction) during the memory stage
                       and during the PC update stage we set the PC to call destination (valC)
                       
                    -- with instruction 'ret', we assign 'valM' (value popped from the stack) to the PC in the PC update stage

        B. SEQ Hardware Structure

            • See figure 4.22 on page 425 for a crude high-level overview of the general process described in section A.

            • Figure 4.23 is a bit complicated so here is a verbose and thorough walkthrough:
            
              (1) fetch Stage:
                - the stage begins by reading the current instruction address from the PC (Program Counter)
                - the PC value is fed to the instruction memory to retrieve the instruction byte, which is parsed to yield the instruction code (icode) 
                  and function code (ifun)
                - the register operands (rA,rB) and the optional 8-byte constant or displacement (valC) are extracted
                - the PC increment unit calculates valP (PC + length of instruction), which is the address of the next sequential instruction
                - all these components are passed forward to the decode stage

              2. Decode Stage 
                - the stage reads up to two operands from the register file
                - the rA and rB register IDs from the fetch stage select the output ports of the register file
                - the contents of the selected registers are read out as valA and valB
                - control logic blocks (srcA, srcB, dstE, dstM) determine which registers are needed for reading and which will be destinations for writing back
                  
              3. Execute Stage                 
                - the ALU A and ALU B inputs are selected by control logic from valA, valB, and valC
                - the ALU fun. control block dictates the arithmetic or logical operation (e.g. addq vs. address calculation) based on the instruction's icode and ifun bits
                - the output of the ALU is valE (the execution result or memory address)
                - for instructions like OPq, the condition codes (CC) are set, and the Cnd logic block determines if a conditional jump (jXX) should be taken

              4. Memory Stage                 
                - the data memory performs either a read or a write operation
                - the memory address is typically valE (from the ALU)
                - for a store operation (rmmovq), the data to be written comes from valA
                - for a load operation (mrmovq), the data read from memory is output as valM
                - the Mem. control block provides the read and write signals to the data memory

              5. Write Back Stage                 
                - the register file has two write ports to handle two potential results:
                  -- the valE result is written to the register specified by the dstE control signal
                  -- the valM result (read from memory) is written to the register specified by the dstM control signal

              6. PC Update                
                - the New PC control block selects the final address (newPC) from three possible sources:
                  (1) valP (the sequential address, for nop, pushq, popq, OPq, etc.)
                  (2) valC (the jump target or the address for a call destination)
                  (3) valM (the return address for ret)
                - this selected newPC is then fed back to the PC register, where it is loaded on the next clock edge, completing the cycle and starting the fetch stage for the next instruction

        C. SEQ Timing

            • This section is very dense so I'm going to summarize the important points that allow for a general understanding of the text without getting too entrenched in the details.

            • Understanding the figures 4.23 and 4.26 - 4.31 absolutely REQUIRES that you know these facts outlined under this bullet point:

              - The Flexible Role of rA (The Data-Mover)
                  -- the rA field's primary function is to handle the data value itself, and moves data between the register file and memory
                  -- as a source (srcA): rA contains the register ID holding the value needed before the memory stage, which includes:
                    •	The second operand for ALU operations (OPq)
                    •	The value to be stored into memory (rmmovq and pushq)
                  -- as a destination (dstM): rA contains the register ID that will receive the value read from memory (load operations mrmovq and popq)
            
              - The Anchored Role of rB (The Address/Destination Anchor)
                  -- The rB field's primary function is to act as an anchor for calculation or destination, making it central to valE (the ALU result)
                  -- As an address anchor (valB): rB holds the base address for all memory access instructions (rmmovq and mrmovq), and its value is crucial for calculating 
                     the effective address valE (valB + valC)
                  -- as an ALU destination (dstE): rB is the consistent destination for the result of any register-to-register operation, including ALU operations (OPq) and 
                     register-to-register moves (rrmovq)

              - This division of labor allows the control logic to handle all instructions uniformly: rB handles the address or the ALU destination, while rA handles 
                the moving data between registers and memory          

              - Understanding icode and ifun

                  -- the icode field is 4 bits wide, which means it can represent 16 unique values. the Y86-64 instruction set, however, only defines 12 distinct instructions, 
                     using 12 of the 16 possible codes shown on page 432:
                  
                      IHALT    0
                      INOP     1
                      IRRMOVQ  2
                      IIRMOVQ  3
                      IRMMOVQ  4
                      IMRMOVQ  5
                      IOPL     6
                      IJXX     7
                      ICALL    8
                      IRET     9
                      IPUSHQ   A
                      IPOPQ    B
              
                  -- in the hardware flow diagrams, the lines from icode are not single wires, but a 4-bit bus carrying the instruction code to multiple logic blocks

                  -- these blocks (Need valC, Need regids, Instr valid) are combinational logic circuits, and each one takes the entire 4-bit icode as input and 
                     outputs a single boolean control signal

                  -- each logic block computes a boolean value based on the instruction type encoded in icode. for example:

                      need_regids = true if icode is in { IRRMOVQ, IOPQ, IPUSHQ, IPOPQ, IIRMOVQ, IRMMOVQ, IMRMOVQ }                    

                      need_valC = true if icode is in { IIRMOVQ, IRMMOVQ, IMRMOVQ, IJXX, ICALL }                    

                      instr_valid = true if icode is one of the twelve legal Y86-64 instruction codes

                  -- ifun (Instruction Function): this 4-bit value refines the operation for instruction groups (like selecting ADD vs SUB for OPq), 
                     but it plays no role in calculating instruction length.
                  
            • Fetch

                - the instruction memory unit in the this stage of the SEQ processor reads 10 bytes starting at the PC address every cycle, 
                  regardless of the instruction type: 

                  -- it must handle the longest possible instruction, which is 10 bytes 
                  -- reading a fixed, maximum-length block simplifies the hardware by avoiding complex control logic for variable-length instructions

                - the split unit immediately extracts the icode and ifun fields from the first byte (instruction specifier byte)

                - the icode then drives the logic to compute three critical control signals (instr_valid, need_regids, and need_valC)

                - the processor then uses the icode and the align unit to select and extract only the relevant fields from those 10 bytes

                  -- the align unit outputs the register specifier byte broken into two 4-bit register specifiers (rA and rB)

                - unused bytes (such as bytes 2–9 for a 2-byte OPq instruction) are simply set to zero

            • Decode and Write-Back

                - ICODE's Role in Controlling Register Ports

                  -- The 4-bit icode signal serves as the input to four control logic blocks (srcA, srcB, dstE, and dstM)
                  -- the rA and rB signals are also inputs to these blocks, and each block determines which register ID is selected as the output

                  +--------------------------+-----------------------------+-----------------------------+------------------------------------------------------------+
                  | icode Category           | srcA (Register ID for valA) | srcB (Register ID for valB) | Rationale                                                  |
                  +--------------------------+-----------------------------+---------------------------+--------------------------------------------------------------+
                  | rrmovq, OPq              | Selects rA                  | Selects rB                  | Reads both source operands for the ALU.                    |
                  | rmmovq                   | Selects rA (data)           | Selects rB (base address)   | rB gives the base address, rA gives or receives data.      |
                  | pushq                    | Selects rA                  | Selects %rsp                | %rsp is the base address/data; rA holds the value to push. |
                  +--------------------------+-----------------------------+-----------------------------+------------------------------------------------------------+

                - the register file performs two simultaneous reads based on the addresses provided by the srcA and srcB logic blocks:

                  -- the register file reads the registers specified by srcA and srcB and outputs their 64-bit values through their corresponding ports (A and B)
               
                - the register file performs two simultaneous writes using the destination IDs determined earlier by the control logic:

                  -- the value valE is written to the register specified by dstE

                    +---------------------------+-------------------------------+---------------------------+
                    | Instruction               | What valE Represents          | Destination Register      |
                    +---------------------------+-------------------------------+---------------------------+
                    | OPq rA, rB                | The result of the arithmetic  | rB                        |
                    |                           | operation valB OP valA        |                           |
                    | i/rrmovq rA, rB           | The moved value 0 + valC/A    | rB                        |
                    | stack Update, call/ret    | The new stack pointer address | %rsp                      |
                    +---------------------------+-------------------------------+---------------------------+

                  -- recall that rB is the destination field for valE (specified by dstE) unless the instruction requires the stack pointer (%rsp) to be updated
                             
                  -- the value valM is written to the register specified by dstM                

                    +------------------+--------------------------------------------------+---------------------------+
                    | Instruction      | What valM Represents                             | Destination Register      |
                    +------------------+--------------------------------------------------+---------------------------+
                    | mrmovq D(rB), rA | The data read from the memory location M₈[valE]  | rA                        |
                    | popq rA          | The data read from the stack top M₈[valA]        | rA                        |
                    +------------------+--------------------------------------------------+---------------------------+

                  -- recall that rA is the destination field for valM (all instructions that load data from the data memory)

            • Execute

                - the ALU computation in this stage takes 2 operands, ALU A and ALU B

                    -- the value of aluA can be valA, valC, or either −8 or +8, depending on the instruction type:

                        word aluA = [                        
                        icode in { IOPQ, IRRMOVQ }: valA;               
                        icode in { IIRMOVQ, IRMMOVQ, IMRMOVQ } : valC;                    
                        icode in { ICALL, IPUSHQ }   : -8;
                        icode in { IRET, IPOPQ }     : 8;                      
                        ];

                - for the OPq instructions, we want the ALU to use the operation encoded in the ifun field of the instruction:

                    word alufun = [
                    icode == IOPQ : ifun;
                    1 : ALUADD;
                    ];

                - the ALU also generates the three signals on which the condition codes are based—zero, sign, and
                  overflow—every time it operates, but we only want to set the condition codes when an OPq instruction is executed:

                    book set_cc = icode in { IOPQ };

                - now we can implement the COND bit flag:

                int cond(unsigned char ccs, unsigned char ifun)
                {
                    int OF = (ccs >> 1) & 1;
                    int ZF = (ccs >> 2) & 1;
                    int SF = (ccs >> 3) & 1;
                    
                    switch (ifun)
                    {
                        case 0:
                            return 1;
                        
                        case 1:
                            return (SF ^ OF) | ZF;
                            
                        case 2:
                            return SF ^ OF;
                            
                        case 3:
                            return ZF;
                            
                        case 4:
                            return !ZF;
                            
                        case 5:
                            return !(SF ^ OF);
                            
                        case 6:
                            return !(SF ^ OF) && !ZF;                            
                    }
                }



                    




