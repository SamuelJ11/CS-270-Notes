WHY LEARN C
• “Portable assembly language”: C maps closely to hardware (registers, memory, instructions) without being tied to one CPU. The compiler does the last-mile translation, so well-written C ports across platforms with small changes.
• Systems programming: kernels, drivers, shells, compilers, DB engines, networking stacks. C compiles to very efficient machine code and avoids hidden runtime costs.
• “No magic”: C omits many high-level features (no objects/GC/auto-growing containers), so performance and behavior are predictable and under your control.
• Unix/Linux API is C-first: POSIX system calls and libc are defined as C functions. (Tip: `man <function>` for docs.)
• Used beyond desktops/servers: embedded/IoT, real-time systems (avionics/robotics), DB engines (MySQL/SQLite), networking (DNS, firewalls), and more.

THE MOST BASIC STATEMENT IN IMPERATIVE LANGUAGES
• Assignment changes program state:
    variable = expression;
  The right-hand side is evaluated, then stored into the left-hand side (an lvalue—i.e., a storage location).

WHAT C PROGRAMS ARE MADE OF
• Types
  – Primitive: char, short, int, long, (optionally long long), float, double. (No built-in boolean in classic C: 0 is “false”; any nonzero is “true”.)
  – Constructed: arrays, structs, unions, pointers.
• Expressions/Operators
  – Arithmetic: +, -, *, /, % (integer division truncates toward zero; % is remainder).
  – Bitwise: &, |, ^, ~, <<, >> (operate on bits; used for flags/masks/packed data).
  – Logical: &&, ||, ! (short-circuit; result is 0 or 1).
• Statements/Composition
  – Blocks: { … } and sequencing with ‘;’.
  – Control flow: if, while, do, for.
  – Functions: name computations, return values, enable reuse. In C, functions provide procedural abstraction (not objects).

C VS. C++
• No classes/objects/namespaces in C. Abstraction is via functions (behavior) and structs (data).
• Strings: arrays of char terminated by a NUL byte '\0'. They are fixed-size buffers you manage. Common pitfalls: forgetting space for '\0', buffer overflows, mixing bytes/characters.
• All parameters are pass-by-value. To let a function update a caller’s variable, pass a pointer (address) and write through it:
    void incr(int *p) { *p += 1; }
    int x = 41; incr(&x); // x == 42
• Arrays are not assignable and decay to pointers in most expressions. To copy arrays use loops or library routines (e.g., memcpy/strcpy with correct sizes).

SCOPE AND LINKAGE (WHERE NAMES ARE VISIBLE)
• Local (block/function) scope:
  – Declared inside a function; includes parameters.
  – Lifetime: entry to exit of the block (automatic storage duration).
• Global, non-static (file-scope without ‘static’):
  – Visible across translation units via external linkage (declare with ‘extern’ in other files).
• Global, static (file-scope with ‘static’):
  – Internal linkage: name is visible only within that source file (compilation unit).
(Aside) ‘static’ on a local variable gives it static storage duration (kept across calls) but block scope.

INSIDE THE MACHINE: REGISTERS, MEMORY, AND SIZES
• Registers: a CPU’s fastest storage. x86-64 has 16 general-purpose 64-bit registers. They hold integers and addresses (pointers) while executing instructions.
• Memory: a large byte-addressable array. An address is the index of a byte. Both code (instructions) and data live in memory. Pointers are variables that store addresses.
• The compiler assigns each variable a location and knows its size and alignment.
• Fundamental C principle: every type has a well-defined size in bytes (platform/ABI dependent).
  – Use sizeof(type) or sizeof expr to get the size at compile time.
  – Common LP64 x86-64 sizes (typical, but check sizeof!):
      char = 1 byte
      short = 2 bytes
      int = 4 bytes
      long = 8 bytes
      long long = 8 bytes
      pointer = 8 bytes
      size_t = 8 bytes
• Literals like 27 are of type int by default; assigning `foo = 27;` stores the 32-bit int value into foo’s bytes (then extended/narrowed as needed by foo’s type).

STRINGS IN C (DETAILS YOU MUST GET RIGHT)
• Representation: contiguous array of chars ending with '\0'. The “length” is the count before '\0'.
• Allocation: need space for the terminator. Example: to store "cat" you need 4 bytes: {'c','a','t','\0'}.
• Common operations: strlen (counts until '\0'), strcpy/strncpy/strlcpy (copy), strcmp (compare). Always ensure the destination buffer is large enough; otherwise you corrupt memory.

BITWISE VS. LOGICAL — WHY THEY MATTER
• Bitwise operators (& | ^ ~ << >>) manipulate bits. Essential for:
  – Flags: set/clear/test single bits (e.g., permissions, device registers).
  – Packing/unpacking fields, efficient arithmetic tricks (shifts multiply/divide by powers of two).
• Logical operators (&& || !) combine truth values. They short-circuit:
  – (a && b): if a is 0 (“false”), b is not evaluated.
  – (a || b): if a is nonzero (“true”), b is not evaluated.

ARRAYS, POINTERS, AND “NO ARRAY ASSIGNMENT”
• An array’s name often “decays” to a pointer to its first element in expressions (e.g., when passed to functions).
• Because arrays are fixed-size blocks, you cannot assign arrays directly:
    int a[3] = {1,2,3}, b[3];
    // b = a; // ERROR
    for (int i = 0; i < 3; ++i) b[i] = a[i];  // OK
• Pointers are just addresses. You can simulate pass-by-reference by passing a pointer and dereferencing it.

“NO MAGIC” IN PRACTICE
• No garbage collection: you must free what you malloc.
• No auto-growing types: you manage sizes, reallocate manually when needed.
• Undefined behavior exists: out-of-bounds, use-after-free, uninitialized reads, integer overflow (signed), etc. The compiler may optimize under assumptions, so avoid UB.

QUICK REFERENCE SNIPPETS
1) Swap with pointers
    void swap(int *a, int *b){ int t=*a; *a=*b; *b=t; }
2) Safe string copy pattern (ensure room for '\0')
    // dest has size DEST_N
    strncpy(dest, src, DEST_N-1);
    dest[DEST_N-1] = '\0';
3) Bit flags
    enum { READ=1<<0, WRITE=1<<1, EXEC=1<<2 };
    unsigned perms = READ | WRITE;
    if (perms & READ) { /* can read */ }

KEY TAKEAWAYS
• C gives you predictability and control—at the cost of responsibility.
• Know your types and sizes (`sizeof`), and how data lives in registers and memory.
• Master pointers/arrays/strings and understand scope/linkage to write correct, portable C.
• Use the Unix “man” pages and libc for system-level programming.