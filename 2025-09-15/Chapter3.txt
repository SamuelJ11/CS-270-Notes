CHAPTER 3: MACHINE LEVEL REPRESENTATIONS OF PROGRAMS

    VI. Control

    • Normally statements are executed sequentially (in the order they appear), but this order can be altered with a jump instruction (usually contingent upon the result of some test)

    A. Condition Codes  

        • In addition to the general purpose registers, the CPU maintains a set of single-bit condition code registers which are tested to perform conditional branches

            - Carry flag        (The most recent operation generated a carry out of the most significant bit)
            - Zero flag         (The most recent operation yielded zero)
            - Sign flag         (The most recent operation yielded a negative value)
            - Overflow flag     (The most recent operation caused a two’s-complement overflow)

        • For the logical operations, such as xor, the carry and overflow flags are set to zero. 
        
        • For the shift operations, the carry flag is set to the last bit shifted out, while the overflow flag is set to zero.

        • There are two instruction classes (having -b, -w, -l, -q forms) that set condition codes without altering any other registers:

            - the CMP instructions set the condition codes according to the difference of their two operands (D - S) - they set the zero flag if the two operands are equal

            - the TEST instructions behave in the same manner as the AND instructions except without altering their destination

    B. Accessing the Condition Codes

        • The SET instruction class allows us to set a single byte to 0 or 1 depending on some combination of the condition codes

            - IMPORTANT!!:  the suffixes for these conditions do NOT specify operand sizes

            - see page 231 for the flags checked for set operations

        • A SET instruction has either one of the low-order single-byte register elements or a single-byte memory location as its destination, setting this byte to either 0 or 1
        
            - for example, if we wanted to check if a < b:

            (a in %rdi, b in %rsi)

            comp:
                cmpq %rsi, %rdi     (a - b)
                setl %al            (if SF ^ OF, set low-order byte of %eax (%ax) to 1)
                movzbl %eax         (clears remaining bits of %eax **and %rax**)  ** In x86-64, any instruction that writes to a 32-bit register will automatically zero out 
                ret                                                                  the upper 32 bits of the corresponding 64-bit register

        • It is important to note how machine code does or does not distinguish between signed and unsigned values

            - some circumstances require different instructions to handle signed and unsigned operations, such as using different versions of right shifts, div and mult instructions, etc

    C. Jump Instructions

        • Two of the jmp instruction jump unconditionally - it can be either a direct or indirect jump:

            - direct jumps use labels: jmp .L1

            - indirect jumps use the * followed by an operand specifier: jmp *%rax (uses the value in %rax as the jump target) 

        • The remaining jumps are conditional, and these jumps require a label, i.e. they can only be direct (see textbook page 234 for examples)

    D. Jump Instruction Encodings

        • The two most common types of encodings for the jmp instruction are PC relative and absolute jumps:

            - PC relative:  encodes the difference between the address of the target instruction and the address of the instruction immediately following the jump

                -- these offsets can be encoded using 1, 2 or 4 bytes

            - Absolute:  4 bytes are used to directly specify the target

        • The assembler and linker select the appropriate encodings for the jmp instruction

        • Consider the following example below:

            1 movq %rdi,%rax
            2 jmp .L2
            3 .L3:
            4 sarq %rax
            5 .L2:
            6 testq %rax,%rax
            7 jg .L3
            8 rep;ret

            // disassembled version of the above machine code
            
            1 0: 48 89 f8     mov %rdi,%rax
            2 3: eb 03        jmp 8 <loop+0x8>  
            3 5: 48 d1 f8     sar %rax         
            4 8: 48 85 c0     test %rax,%rax
            5 b: 7f f8        jg 5<loop+0x5>
            6 d: f3 c3        repzretq

            - in the disassembled code, the first jump starts at address 0x3, with the next address at 0x5 

            - the offset for the first jump (0x3) is calculated as the (address of the target (0x8)) - (the address of the next instruction (0x5))  

            - the second jump starts at address 0xb, with the next address at 0xd

            - the offset for the second (0xf8) jump is subsequently calculated as (0x5 - 0xd)   *0x5 − 0xd = -8, written as 0xf8 in two’s complement.

    E. Implementing Conditional Branches with Conditional Control

        • The most general way to translate conditional and unconditional expessions and statements from C into machine code is to use a combination of conditional and 
          unconditional jumps

        • Assembly doesn’t have 'if-else' directly: it only has conditional jumps, so compilers usually follow this template:         

            t = test-expr;    // evaluate expression
            if (!t)           // if test-expr == 0 (false) ...
                goto false;   // jump to the false branch

            then-statement    // if we didn’t jump, that means t != 0, so execute the "then" branch

            goto done;        // skip over the else branch

            false:
            else-statement

            done:

    F. Implementing Conditional Branches with Conditional Moves

        • The conventional way to implement conditional operations is through a conditional transfer of control:

            - use a branching to jump to different code depending on the condition

        • A more efficient strategy  is through a conditional transfer of data:

            - compute both possible results, then use a special instruction to select the correct one without branching.

        •  Compare both forms of C code and thier corresponding machine code representations to see how conditional data transfers are more efficient:
       
            C code                                             Assembly
            ------------------------------------------------   ----------------------------------------
            long absdiff_se(long x, long y) {                  absdiff_se:              # x in %rdi, y in %rsi
                long result;                                   cmpq %rsi, %rdi          # Compare x:y
                if (x < y) {                                   jge .L2                  # If >= goto x_ge_y
                    lt_cnt++;                                  addq $1, lt_cnt(%rip)    # lt_cnt++
                    result = y - x;                            movq %rsi, %rax
                }                                              subq %rdi, %rax          # result = y - x
                else {                                         ret                      # Return
                                                            .L2:
                    ge_cnt++;                                  addq $1, ge_cnt(%rip) # ge_cnt++
                    result = x - y;                            movq %rdi, %rax
                }                                              subq %rsi, %rax      # result = x - y
                return result;                                 ret                  # Return
            }                                                 

            C code                                             Assembly
            ------------------------------------------------   ----------------------------------------
            long absdiff(long x, long y) {                     absdiff:             # x in %rdi, y in %rsi
                long result;                                   movq %rsi, %rax      # rax = y
                if (x < y)                                     subq %rdi, %rax      # rval = y - x
                    result = y - x;                            movq %rdi, %rdx      # rdx = x
                else                                           subq %rsi, %rdx      # eval = x - y
                    result = x - y;                            cmpq %rsi, %rdi      # Compare x:y
                return result;                                 cmovge %rdx, %rax    # If >=, rval = eval
            }                                                  ret                  # Return

        • Modern Processors use pipelining, where an instruction is broken into stages, each performing one small portion of the required operation

            - multiple stages can thus be overlapped in the pipeline, but to do this requires being able to determine the sequence of instructions to be executed well ahead of time

                -- the processor cannot do this when it encounters a conditional jump: the branch condtion must be evaluated first
            
            - modern CPU's can guess the outcome of a branch with around %90 accuracy, but if the guess is wrong, all instructions loaded along the wrong path must be discarded

                -- this misprediction can incur a serious performance penalty

        • Below is a figure showing the condtional move insructions:

            Instruction   Synonym    Condition (flags)                   Meaning
            ---------------------------------------------------------------------------
            cmove   S,R   cmovz         ZF                               Equal / zero
            cmovne  S,R   cmovnz        ~ZF                              Not equal / not zero
            cmovs   S,R                 SF                               Negative
            cmovns  S,R                 ~SF                              Nonnegative
            cmovg   S,R                 ~(SF ^ OF) & ~ZF                 Greater (signed >)
            cmovge  S,R   cmovnl        ~(SF ^ OF)                       Greater or equal (signed >=)
            cmovl   S,R                 (SF ^ OF)                        Less (signed <)
            cmovle  S,R   cmovnle       (SF ^ OF) | ZF                   Less or equal (signed <=)
            cmova   S,R                 ~CF & ~ZF                        Above (unsigned >)
            cmovae  S,R   cmovnb        ~CF                              Above or equal (unsigned >=)
            cmovb   S,R                 CF                               Below (unsigned <)
            cmovbe  S,R   cmovna        CF | ZF                          Below or equal (unsigned <=)

            - the source and destination values can be 16, 32 or 64 bits 
            
            - the assembler can determine the operand length of a conditonal move from the name of the destination register 

        • In conditional data transfer, both expressions are computed first, and the result is chosen with a conditional:

            - model:  v= test-expr ? then-expr : else-expr;

            - implementation:   v = then-expr;
                                ve = else-expr;
                                t = test-expr;
                                if (!t) v = ve;

        • Not all conditional expressions can be compiled using conditional moves

            - if either of these two expressions could potentially cause an error or have a side effect, this could result in invalid behavior

    G. Loops
        



        
                                                                 


