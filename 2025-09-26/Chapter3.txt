CHAPTER 3: MACHINE LEVEL REPRESENTATIONS OF PROGRAMS

    VIII. Array Allocation and Access

        • Arrays in C are one means of aggregating primitive data types into larger data types.

        A. Basic Principles

            • Consider the declaration of the form T A[N], where:

                - L * N denotes the size of the contiguous region allocated in memory (L = size of data type T)

                - A is introduced as an identifier that can be used as a pointer to the beginning of the array.

                    -- let the value of this pointer be xₐ

                - array element i will be stored at xₐ + (L * i)

            • For example, if E is declared as int E[N], and we wish to evaluate E[i], where the address of E is stored in register %rdx and 'i' is stored in %rcx, then 
              movl(%rdx, %rcx, 4), %eax will perform the address computation xₑ + 4i, read that memory location, and store the result in %eax.

        B. Pointer Arithmetic 

            • The array dereference A[i] is identical to the expression *(A + i)

            • Below are some examples involving 'E' from before and thier corresponding assembly code implementation


            | Expression | Type | Value       | Assembly Code               |
            | ---------- | ---- | ----------- | --------------------------- |
            | E          | int* | xE          | movq %rdx, %rax             |
            | E[0]       | int  | M[xE]       | movl (%rdx), %eax           |
            | E[i]       | int  | M[xE+4i]    | movl (%rdx,%rcx,4), %eax    |
            | &E[2]      | int* | xE+8        | leaq 8(%rdx), %rax          |
            | E+i-1      | int* | xE+4i−4     | leaq -4(%rdx,%rcx,4), %rax  |
            | *(E+i-3)   | int  | M[xE+4i−12] | movl -12(%rdx,%rcx,4), %eax |
            | &E[i]-E    | long | i           | movq %rcx, %rax             |

            * The result is being stored in either register %eax (for data) or register %rax (for pointers).

        C. Nested Arrays

            • int A[5][3] is a 2D array: 5 rows and 3 columns

                - think of it as an array of 5 arrays, and each array holds 3 integers

            • typedef int row3_t[3]
              row3_t A[5]

                - here row3_t is a type alias for int[3] - an array of 3 integers

                - then A[5] is an array of 5 elements, where each element is a row3_t (exactly the same as A[5][3])

            • The array elements are ordered in memory in row-major order, meaning all elements of row 0, which can be written A[0], followed by all 
              elements of row 1 (A[1]), and so on

            • To access elements of multi-dimensional arrays, the compiler generates code to compute the offset of the desired element and then uses one of the mov 
              instructions with the start of the array as the base address and the (possibly scaled) offset as an index:

                - in general, for an array declared as T A[R][C], array element A[i][j] is at memory address:

                    -- &A[i][j] = xₐ + L(C * i + j), where L is the size of the data type T in bytes.

                - to reach element A[i][j], you need:

                    -- i full rows ahead: each row has C elements → offset = i * C

                    -- j elements within the row → offset = j

            • Suppose A is a 5 x 3 2D array, then the array element A[i][j] can be copied to register %eax by the following code:

                - A in %rdi, i in %rsi, and j in %rdx   *L = 4, C = 3

                    -- leaq (%rsi,%rsi,2), %rax – compute 3 * i                     *from (C * i)

                    -- leaq (%rdi,%rax,4), %rax – compute xₐ + 12i                  *from (xₐ + L(C * i))

                    -- movl (%rax,%rdx,4), %eax – read from M[(xₐ + 12i) + 4j]      *equivalently M[xₐ + 4(3i + j)]

        D. Fixed Array size

            • The C compiler is able to make many optimizations for code operating on multi-dimensional arrays of fixed size.

            • Here is an example with the compilation flag -O1:

                - #define N 16
                  typedef int fix_matrix[N][N];

                - using a #define for N is good coding practice as it allows the programmer to refer to the array size symbolically rather than using a literal number.

                    - if you ever need to change the array size, you only need to change the #define N 16 line, and the change propagates throughout the code.
            
            • Suppose we wish to compute ONE ELEMENT in the product matrix of two fix_matrices (N x N) together, where A and B are these matrices, and C is 
              the product of both A and B:

                - C[i][k] = (A[i][0] * B[0][k]) + (A[i][1] * B[1][k]) + . . . (A[i][N-1] * B[N-1][k])

                - This can be expressed with the follow equation:

                    -- C = ∑j = 0:N-1 (A[i][j] * B[j][k])

                - to compute the entire matrix C, we must do this for every value i and k

                * see 'fix_matrix.c' for an implementation and example in C

            • The C code in 'fix_matrix.c' is implemented by by the following assembly code, where:

                - int *Aptr = &A[i][0];  // points to the first element of row i in A
                - int *Bptr = &B[0][k];  // points to the first element of column k in B
                - int *Bend = &B[N][k];  // points one past the last element of column k in B

                *also keep in mind that:

                - each element of the matrix is an int, which is 4 bytes
                - each row of the matrix has 16 elements (N = 16)
                - so the total size of one row in bytes = 16 × 4 = 64 bytes
                - when referencing the formula, L = 4, C = 16, and j = k                    

                    1  fix_prod_ele:
                    2      salq $6, %rdx                # Compute 64 * i
                    3      addq %rdx, %rdi              # Compute Aptr = xA + 64*i = &A[i][0]           *from (xₐ + L(C * i))
                    4      leaq (%rsi, %rcx, 4), %rcx   # Compute Bptr = xB + 4*k = &B[0][k]            *from (xₐ + L(C * 0 + j))   
                    5      leaq 1024(%rcx), %rsi        # Compute Bend = xB + 4*k + 1024 = &B[N][k]     *from (xₐ + L(C * 16 + j)) --> xₐ + 4j + 1024
                    6      movl $0, %eax                # Set result = 0
                    7  .L7:                             # loop:
                    8      movl (%rdi), %edx            # Read *Aptr
                    9      imull (%rcx), %edx           # Multiply by *Bptr
                    10     addl %edx, %eax              # Add to result
                    11     addq $4, %rdi                # Increment Aptr++                              *Aptr moves within the row (+4)
                    12     addq $64, %rcx               # Increment Bptr += N                           *Bptr must move down the column, so it skips 16 elements each time (+64)
                    13     cmpq %rsi, %rcx              # Compare Bptr to Bend
                    14     jne .L7                      # If not equal, go to loop
                    15     rep; ret                     # Return

        E. Variable Size arrays

            • C99 introduced variable-length arrays (VLAs):

                - int n = 10;
                  int A[n][n];  // array size determined at runtime

                - the function below shows how to access an element of a VLA:

                    int var_ele(long n, int A[n][n], long i, long j) 
                    {
                        return A[i][j];
                    }

                - the compiler still knows how to compute the memory offset internally using row-major mapping, but we no longer need to do pointer arithmetic manually

            • GCC generates assembly code for this referencing function as:
                
                // n in %rdi, A in %rsi, i in %rdx, j in %rcx

                1  var_ele:
                2      imulq %rdx, %rdi              # Compute n * i
                3      leaq (%rsi, %rdi, 4), %rax    # Compute xA + 4 * (n * i)
                4      movl (%rax, %rcx, 4), %eax    # Read from M[xA + 4 * (n * i) + 4 * j]
                5      ret

            • The dynamic version must use a multiplication instruction to scale i by n, rather than a series of shifts and adds. On some processors, this multiplication can 
              incur a significant performance penalty, but it is unavoidable in this case.

            * See textbook page 292 for C code and assembly that multiplies two VLA's and computes thier corresponding entry.


    XI. Heterogenous Data Structures

        • C provides two mechanisms for creating data types by combining objects of different types:

            - structures, declared using the keyword 'struct', aggregate multiple objects into a single unit

            - unions, declared using the keyword union, allow an object to be referenced using several different types

        A. Structures

            • The implementation of structures is similar to that of arrays in that all of the components of a structure are stored in a contiguous 
              region of memory and a pointer to a structure is the address of its first byte. 

                - the compiler remembers where each field is located relative to the start of the struct (different data types have different offsets)

                    - To access the fields of a structure, the compiler generates code that adds the appropriate offset to the address of the structure

            • Suppose we have the following struct below, where variable 'r' of type struct rec* is stored in register %rdi:

                struct rec {
                int i;      // 4 bytes, offset 0
                int j;      // 4 bytes, offset 4
                int a[10]   // 40 bytes, offset 8
                int *p      // 8 bytes, offset 52
                };

                * r is a pointer to rec (the addres of the struct)
                * i and j are field names inside the structure

                - this can modeled by the following assembly code:

                    1   movl (%rdi), %eax      # load r->i into %eax
                    2   movl %eax, 4(%rdi)     # store %eax into r->j

                    -- %rdi holds the address of the struct (e.g., 1000).
                    -- r->i is at offset 0, so (%rdi) accesses it directly.
                    -- r->j is at offset 4, so 4(%rdi) means "address in %rdi + 4".

                    summary: field j lives at offset 4 in the struct, so the previous line writes whatever is in %eax (the value of i) 
                    that memory location: this overwrites the old value of j with the value of i, effectively copying the value of r->i to
                    to r->j.

                - to generate a pointer to an object within a struct, we can simply add the field's offset to the structure address:

                    --  if &r = 0x1000, then &(r->a[1]) is generated by performing (&r + offset + index * type) = 0x1000 + 0x8 + 0x4(1) = 0x100c

                    Registers: r in %rdi, i in %rsi
                    1 leaq 8(%rdi,%rsi,4), %rax 

            • Finally we consider the the last example:

                r->p = &r->a[r->i + r->j];

                1. computes the index r->i + r->j.
                2. finds the element in the array a at that index: r->a[r->i + r->j].
                3. takes the address of that element with &.
                4. stores that address in the pointer r->p.

                - the following assembly models this: 

                Registers: r in %rdi

                1 movl 4(%rdi),%eax             Get r->j
                2 addl (%rdi),%eax              Add r -> i to r -> j
                3 cltq                          Extend to 8 bytes
                4 leaq 8(%rdi,%rax,4),%rax      Compute &r->a[r->i + r->j]
                5 movq %rax,16(%rdi)            Store in r-> p

        B. unions
        
            • Unions provide a way to circumvent the type system of C, allowing a single object to be referenced using multiple types

            • Rather than having the different fields reference different blocks of memory, they all reference the same block:

                - only one field can hold a meaningful value at a time.
 
                - for pointer p of type union U3 *, references p->c, p->i[0], and p->v would all reference the beginning of the data structure:

                    union U3 {
                    char c;         //offset = 0
                    int i[2];       //offset = 0
                    double v;       //offset = 0
                    };

                - *size = 8 (the size of its largest field)

            • If you know that only one of several fields will ever be used at a time, you don’t need separate memory for each field, so a Union
              would be appropriate here:

                - consider a binary tree, a data structure made up of nodes where each node can have at most two children

                    -- internal nodes ave at least one child (left, right, or both), and do not store actual data, but 
                        exist to connect other nodes.

                    -- leaf nodes have no children (both left and right pointers are null) and store the actual data.
                
                - in the struct example of a binary tree, every node requires 32 bytes, with half of the bytes wasted for each type of node.


                    struct node_s {
                        struct node_s *left;
                        struct node_s *right;
                        double data[2];
                    };

                    *leaf nodes don't have children, so the left and right nodes are wasted (16 bytes wasted)
                    *internal nodes don't store data, so the data[2] field is unused (16 bytes wasted)

                    
                - in the union example below, every node will require just 16 bytes. 

                    union node_u {
                        struct {
                        union node_u *left;
                        union node_u *right;
                        } 
                        internal;
                        double data[2];
                    };

                    * if the node is a leaf, you use data[2] (16 bytes)
                    * if the node is internal, you use 'internal' (16 bytes)

                * both examples use struct to group the left and right node pointers 

                - if we have a pointer to a union (union node_u *n), then 'n' is a pointer to a union node

                    -- n->data[0] and n->data[1] accesses the data stored in a leaf node
                    -- n->internal.left and n->internal.right accesses the children of an internal node
                    
                            


