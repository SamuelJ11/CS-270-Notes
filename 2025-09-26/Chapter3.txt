CHAPTER 3: MACHINE LEVEL REPRESENTATIONS OF PROGRAMS

    VIII. Array Allocation and Access

        • Arrays in C are one means of aggregating primitive data types into larger data types.

        A. Basic Principles

            • Consider the declaration of the form T A[N], where:

                - L * N denotes the size of the contiguous region allocated in memory (L = size of data type T)

                - A is introduced as an identifier that can be used as a pointer to the beginning of the array.

                    -- let the value of this pointer be xₐ

                - array element i will be stored at xₐ + (L * i)

            • For example, if E is declared as int E[N], and we wish to evaluate E[i], where the address of E is stored in register %rdx and 'i' is stored in %rcx, then 
              movl(%rdx, %rcx, 4), %eax will perform the address computation xₑ + 4i, read that memory location, and store the result in %eax.

        B. Pointer Arithmetic 

            • The array dereference A[i] is identical to the expression *(A + i)

            • Below are some examples involving 'E' from before and thier corresponding assembly code implementation


            | Expression | Type | Value       | Assembly Code               |
            | ---------- | ---- | ----------- | --------------------------- |
            | E          | int* | xE          | movq %rdx, %rax             |
            | E[0]       | int  | M[xE]       | movl (%rdx), %eax           |
            | E[i]       | int  | M[xE+4i]    | movl (%rdx,%rcx,4), %eax    |
            | &E[2]      | int* | xE+8        | leaq 8(%rdx), %rax          |
            | E+i-1      | int* | xE+4i−4     | leaq -4(%rdx,%rcx,4), %rax  |
            | *(E+i-3)   | int  | M[xE+4i−12] | movl -12(%rdx,%rcx,4), %eax |
            | &E[i]-E    | long | i           | movq %rcx, %rax             |

            * The result is being stored in either register %eax (for data) or register %rax (for pointers).

        C. Nested Arrays

            • int A[5][3] is a 2D array: 5 rows and 3 columns

                - think of it as an array of 5 arrays, and each array holds 3 integers

            • typedef int row3_t[3]
              row3_t A[5]

                - here row3_t is a type alias for int[3] - an array of 3 integers

                - then A[5] is an array of 5 elements, where each element is a row3_t (exactly the same as A[5][3])

            • The array elements are ordered in memory in row-major order, meaning all elements of row 0, which can be written A[0], followed by all 
              elements of row 1 (A[1]), and so on

            • To access elements of multi-dimensional arrays, the compiler generates code to compute the offset of the desired element and then uses one of the mov 
              instructions with the start of the array as the base address and the (possibly scaled) offset as an index:

                - in general, for an array declared as T A[R][C], array element A[i][j] is at memory address:

                    -- &A[i][j] = xₐ + L(C * i + j), where L is the size of the data type T in bytes.

                - to reach element A[i][j], you need:

                    -- i full rows ahead: each row has C elements → offset = i * C

                    -- j elements within the row → offset = j

            • Suppose A is a 5 x 3 2D array, then the array element A[i][j] can be copied to register %eax by the following code:

                - A in %rdi, i in %rsi, and j in %rdx   *L = 4, C = 3

                    -- leaq (%rsi,%rsi,2), %rax – compute 3 * i                     *from (C * i)

                    -- leaq (%rdi,%rax,4), %rax – compute xₐ + 12i                  *from (xₐ + L(C * i))

                    -- movl (%rax,%rdx,4), %eax – read from M[(xₐ + 12i) + 4j]      *equivalently M[xₐ + 4(3i + j)]

        D. Fixed Array size

            • The C compiler is able to make many optimizations for code operating on multi-dimensional arrays of fixed size.

            • Here is an example with the compilation flag -O1:

                - #define N 16
                  typedef int fix_matrix[N][N];

                - using a #define for N is good coding practice as it allows the programmer to refer to the array size symbolically rather than using a literal number.

                    - if you ever need to change the array size, you only need to change the #define N 16 line, and the change propagates throughout the code.
            
            • Suppose we wish to compute ONE ELEMENT in the product matrix of two fix_matrices (N x N) together, where A and B are these matrices, and C is 
              the product of both A and B:

                - C[i][k] = (A[i][0] * B[0][k]) + (A[i][1] * B[1][k]) + . . . (A[i][N-1] * B[N-1][k])

                - This can be expressed with the follow equation:

                    -- C = ∑j = 0:N-1 (A[i][j] * B[j][k])

                - to compute the entire matrix C, we must do this for every value i and k

                * see 'fix_matrix.c' for an implementation and example in C

            • The C code in 'fix_matrix.c' is implemented by by the following assembly code, where:

                - int *Aptr = &A[i][0];  // points to the first element of row i in A
                - int *Bptr = &B[0][k];  // points to the first element of column k in B
                - int *Bend = &B[N][k];  // points one past the last element of column k in B

                *also keep in mind that:

                - each element of the matrix is an int, which is 4 bytes
                - each row of the matrix has 16 elements (N = 16)
                - so the total size of one row in bytes = 16 × 4 = 64 bytes
                - when referencing the formula, L = 4, C = 16, and j = k                    

                    1  fix_prod_ele:
                    2      salq $6, %rdx                # Compute 64 * i
                    3      addq %rdx, %rdi              # Compute Aptr = xA + 64*i = &A[i][0]           *from (xₐ + L(C * i))
                    4      leaq (%rsi, %rcx, 4), %rcx   # Compute Bptr = xB + 4*k = &B[0][k]            *from (xₐ + L(C * 0 + j))   
                    5      leaq 1024(%rcx), %rsi        # Compute Bend = xB + 4*k + 1024 = &B[N][k]     *from (xₐ + L(C * 16 + j)) --> xₐ + 4j + 1024
                    6      movl $0, %eax                # Set result = 0
                    7  .L7:                             # loop:
                    8      movl (%rdi), %edx            # Read *Aptr
                    9      imull (%rcx), %edx           # Multiply by *Bptr
                    10     addl %edx, %eax              # Add to result
                    11     addq $4, %rdi                # Increment Aptr++                              *Aptr moves within the row (+4)
                    12     addq $64, %rcx               # Increment Bptr += N                           *Bptr must move down the column, so it skips 16 elements each time (+64)
                    13     cmpq %rsi, %rcx              # Compare Bptr to Bend
                    14     jne .L7                      # If not equal, go to loop
                    15     rep; ret                     # Return

        E. Variable Size arrays

            • C99 introduced variable-length arrays (VLAs):

                - int n = 10;
                  int A[n][n];  // array size determined at runtime

                - the function below shows how to access an element of a VLA:

                    int var_ele(long n, int A[n][n], long i, long j) 
                    {
                        return A[i][j];
                    }

                - the compiler still knows how to compute the memory offset internally using row-major mapping, but we no longer need to do pointer arithmetic manually

            • GCC generates assembly code for this referencing function as:
                
                // n in %rdi, A in %rsi, i in %rdx, j in %rcx

                1  var_ele:
                2      imulq %rdx, %rdi              # Compute n * i
                3      leaq (%rsi, %rdi, 4), %rax    # Compute xA + 4 * (n * i)
                4      movl (%rax, %rcx, 4), %eax    # Read from M[xA + 4 * (n * i) + 4 * j]
                5      ret

            • The dynamic version must use a multiplication instruction to scale i by n, rather than a series of shifts and adds. On some processors, this multiplication can 
              incur a significant performance penalty, but it is unavoidable in this case.

            * See textbook page 292 for C code and assembly that multiplies two VLA's and computes thier corresponding entry.






            


