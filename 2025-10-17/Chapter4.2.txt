CHAPTER 4: PROCESSOR ARCHITECTURE

    II. Logic Design and the Hardware Control Language HCL

        B. Combinational Circuits and HCL Boolean Expressions

            • simple multiplexer circuit given by the expression bool out = (s && a) || (!s && b)

                - here 's' is the control bit

        C. Word-Level Combinational Circuits and HCL Integer Expressions

            • In HCL, word-level signals are declared as an int without specifying the word size.

            • Referencing the multiplexer circuit from page 405, we can see how the circuit is described in HCL using case notation:

                word Out = [
                    s: A;
                    1: B;
                ];

                - in this code, the second selection expression is simply 1, indicating that this
                  case should be selected if no prior one has been
                
                - this is the way to specify a default case in HCL

            • The selection expressions can sometimes be simplified since only the first matching case is selected.

        D. Set Membership

            • A concise way to represent the circuit at the bottom of page 408 is using set notation:

                bool s1 = code == 2 || code == 3;
                bool s0 = code == 1 || code == 3;

                - can be written more concisely as:

                bool s1 = code in { 2, 3 };
                bool s0 = code in { 1, 3 };

        E. Memory and Clocking

            • Hardware registers (like those discussed in EE280) are distinct from machine-language programming registers, so
              we make the distinction between "hardware registers" and "program registers", respectively.

            • Since the state of hardware registers only change on the rising edge of the clock, they serve as barriers between the
              combinational logic in different parts of the circuit.

              - the Y86-64 processors will use clocked registers to hold the program counter (PC), the condition codes (CC),
                and the program status (Stat).

            • Consider the diagram below of a register file (simplified)

                            +----------------------+
                            |      Register file   |
                            |                      |
                srcA ---> A                          W <--- dstW
                valA <---   |                      | ---> valW
                            |                      |
                srcB ---> B                        |
                valB <---   |                      |
                            +----------------------+
                                            ↑
                                          clock

                - this register file has two read ports, named 'A' and 'B', and one write port, named 'W'
                
                - such a multiported random access memory allows multiple read and write operations to take place simultaneously

                - each read port has:

                    (1) an address input (srcA or srcB): tells the register file which register to read

                    (2) a data output (valA or valB): gives you the value stored in that register

                - the write port has:

                    (1) an address input (dstW): tells the register file which register to write to

                    (2) a data input (valW): the value to store in that register

                - writing happnes on the rising edge of a clock signal

                * the register file is NOT a combinational circuit, since it has internal storage

            • The addresses that are the port inputs are simply the register identifiers show in figure 4.4 on page 387

                - when dstW is set to the special ID value 0xF, no program register is written.

            • Lets see what happens if the CPU tries to read and write data from/to the same register simultaneously:

                - assume that the current state for register 1 (%rcx) is a shown below:

                            srcA = 1     (read register %rcx)
                            dstW = 1     (write register %rcx)
                            valW = 99    (value being written)

                (1) before the clock edge — the register file still holds the old value in %rcx (42), So the read port (valA) 
                    outputs the old value.

                (2) at the clock edge — the write port writes the new value (99) into %rcx.

                (3) immediately after the clock edge — the read port output changes to the new value (99), because the contents of 
                    %rcx have been updated.

                    Time           |  Register %rcx |  valA (read)  |  valW (write)
                    ------------------------------------------------------
                    Before clock ↑ | 42 (old value) | 42            | 99 (pending write)
                    At clock ↑     | 99 (updated)   | 42 → 99       |
                    After clock ↑  | 99 (new value) | 99            | 99





