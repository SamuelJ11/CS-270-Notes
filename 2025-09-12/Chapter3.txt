CHAPTER 3: MACHINE LEVEL REPRESENTATIONS OF PROGRAMS

    X.  Combining Control and Data in Machine-Level Programs

        A. Understanding Pointers

            • Every pointer has an associated type (int, char, etc)

                - int *ip: a pointer to an object of type int

                - char **cpp: a pointer to a pointer to an object of type char

                - void *: generic pointer, cannot directly dereference because the compiler doesn’t yet know the size of the object it points to

            • Every pointer has a value, which is an address of some object of the designated type

                -- The special NULL value indicates that the pointer does not point anywhere.
            
            • Pointers are created with the ‘&’ operator

            • Pointers are dereferenced with the ‘*’ operator. 

            • Arrays and pointers are closely related:

                - array referencing has the exact same effect as pointer arithmetic and dereferencing

                    -- A[3] = *(A + (3 * i)) 

                    * the 3 here means index by three, and the 'i' corresponds the scalar value (size of A's data type)
                    
                    * so if A[] is of type int, the second expression takes the base address of A (A[0]) and adds 3 * 4 (i = 4 bytes for an int) to it 
                      to get the address of the fourth element

            • Casting from one type of pointer to another changes its type but not its value.

                - Pointer arithmetic depends on type:  p + i = p + i*(sizeof(p))

                    -- example 1:  char* p = p

                                   (int*) p + 7 = p + 7(4) = p + 28

                                   (int*) (p + 7) = p + 7(1) = p + 7

                    * casting has higher precedence than addition

            • Pointers can also point to functions.

                - This provides a powerful capability for storing and passing references to code.

                    -- see funcpointer.c for an example of how this works

                - The value of a function pointer is the address of the first instruction in the machine-code representation of the function.

        B. Life in the Real World: Using the GBD Debugger

            • See page 308 for useful gdb commands that help when working with machine-level x86-64 programs

                - it is very helpful to first run objdump to get a disassembled version of the program

        C. Out-of-Bounds Memory References and Buffer Overflow

            • For an illustrative example, reference the code in 'gets.c' and consider the character array called buf[8] that can store at most 7 characters:
            
                Stack Bottom (Higher Addresses)                                   
                    +---------------------+
                    |  saved registers    |  
                    +---------------------+
                    |  return address     |  
                    +---------------------+
                    |  unused space (16B) |  
                    +---------------------+
                    | buf[0..7]   (8B)    |  
                    +---------------------+
                Stack Top (%rsp) (Lower Addresses)                

                - 24 bytes are allocated on the stack for buf[8]
                - the 16 bytes between `buf` and the stored return pointer are not used. As long as the user types at most seven characters, the string returned by `gets` 
                  (including the terminating null) will fit within the space allocated for `buf`
                - however, if the string is longer, `gets` will overwrite some of the information stored on the stack. 
                  As the string gets longer, the following information will be corrupted:

                    -- 0–7 none
                    -- 9–23 unused stack space
                    -- 24–31 return address
                    -- 32+ saved state in caller

            • Unfortunately, a number of commonly used library functions, including strcpy, strcat, and sprintf, can generate a sequence of bytes without any indication 
              of the size of the destination buffer. 
            
                - such conditions can lead to vulnerabilities to buffer overflow.

            * Run the excecutable file 'getline' with the gdb debugger to see how buffer overflow occurs in real time

            • Buffer overflow attacks can be dangerous because a pernicious attacker can purposely overwrites adjacent memory on the stack, including the saved return address:

                - When the current function tries to return, the CPU jumps to an arbitrary memory location where the malicious code is executed

        D. Thwarting Buffer Overflow Attacks

            • In order to insert exploit code into a system, the attacker needs to inject both the code as well as a pointer to this code as part of the attack string

                - generating this pointer requires knowing the stack address where the string will be located.
            
            • The idea of stack randomization is to make the position of the stack vary from one run of a program to another. 
            
                - thus, even if many machines are running identical code, they would all be using different stack addresses.

            • Recent versions of gcc incorporate a mechanism known as a stack protector into the generated code to detect buffer overruns. 
            
                - the idea is to store a special canary value in the stack frame between any local buffer and the rest of the stack state

                - if a buffer overflow overwrites the return address, it usually also overwrites the canary

                - before the function returns, it checks the canary: if the canary is different, it knows a buffer overflow occurred and aborts execution

            • Modern systems mark memory pages with separate permissions (read, write, execute). Marking the stack/data as non-executable (the NX / DEP feature) prevents code 
              injected into those regions from being run directly.

                - this stops the simplest form of code-injection attacks because if the stack/data pages aren’t executable, those injected bytes can’t be jumped to and executed.

        E. Supporting Variable-Size Stack Frames

            • Below is a detailed walkthrough of a function that creates a variable sized array. 
            
                * see 'vframe.c' to test the function below with some values

                // C code

                long vframe(long n, long idx, long *q) 
                {
                    long i;
                    long *p[n];
                    p[0] = &i;
                    for (i = 1; i < n; i++)
                        p[i] = q;
                    return *p[idx];
                }

                // Assembly Code

                1 vframe:
                2 pushq %rbp
                3 movq %rsp, %rbp
                4 subq $16, %rsp
                5 leaq 22(,%rdi,8), %rax
                6 andq $-16, %rax
                7 subq %rax, %rsp
                8 leaq 7(%rsp), %rax
                9 shrq $3, %rax
                10 leaq 0(,%rax,8), %r8                      
                11 movq %r8, %rcx

                12 .L3:
                13 movq %rdx, (%rcx,%rax,8)
                14 addq $1, %rax
                15 movq %rax, -8(%rbp)
                16 .L2:
                17 movq -8(%rbp), %rax
                18 cmpq %rdi, %rax
                19 jl .L3

                20 leave
                21 ret         

                
                // Function Prologue: Setting Up the Stack Frame

                vframe:
                This is the label for the start of the vframe function. The function arguments are passed via registers: n in %rdi, idx in %rsi, and q in %rdx.

                Line 2: pushq %rbp
                Action: Pushes the current value of the base pointer (%rbp) onto the stack.
                Purpose: This saves the caller's frame pointer, as %rbp is a callee-saved register.

                Line 3: movq %rsp, %rbp
                Action: Copies the value of the stack pointer (%rsp) into the base pointer (%rbp).
                Purpose: Establishes a new frame pointer for the current function. All local variables will now be referenced relative to this stable address.

                Line 4: subq $16, %rsp
                Action: Subtracts 16 bytes from the stack pointer.
                Purpose: Allocates space on the stack for the local variable i (8 bytes) and some padding (8 bytes). i will be located at %rbp - 8.

                Lines 5-7:
                Action: These three instructions collectively allocate the variable-size array p.
                Line 5: leaq 22(,%rdi,8), %rax
                Calculates 22 + 8 * n (since n is in %rdi and each pointer is 8 bytes) and stores it in %rax. The 22 is padding to ensure proper alignment.
                Line 6: andq $-16, %rax
                Performs a bitwise AND with ...11110000 to align the calculated size in %rax to a 16-byte boundary.
                Line 7: subq %rax, %rsp
                Subtracts the final, aligned size from the stack pointer, allocating the required space for array p.

                Lines 8-11:
                Action: These lines calculate the address of the beginning of the array p and store it in a register for easy access.
                Line 11: movq %r8, %rcx
                The final address of p (calculated in the preceding lines) is moved into %rcx. This register will be used as the base address for accessing p's elements. %rcx has the value of %rsp + 8

                // Initialization: Running the For-Loop

                Line 12: .L3:
                Action: This is the label for the start of the loop.
                Purpose: The for loop in the C code translates to this section. The loop counter i is held in %rax.

                Line 13: movq %rdx, (%rcx,%rax,8)
                Action: This is the core of the loop, corresponding to p[i] = q.
                Purpose: Moves the value of q (in %rdx) into the memory location p[i] (toward the bottom of the stack right after local variables). The address is calculated as base_address + index * scale, 
                         where base_address is %rcx, index is %rax (i), and the scale is 8 (size of a pointer).

                Line 14: addq $1, %rax
                Action: Increments the value of i (in %rax) by 1.

                Line 15: movq %rax, -8(%rbp)
                Action: Stores the updated value of i back onto the stack at the address %rbp - 8.

                Line 17: movq -8(%rbp), %rax
                Action: Retrieves the value of i from the stack and places it back into %rax.

                Line 18: cmpq %rdi, %rax
                Action: Compares i (in %rax) with n (in %rdi).
                Purpose: This is the loop condition (i < n).

                Line 19: jl .L3
                Action: if i is less than n, the program jumps back to the .L3 label to continue the loop.

                // Function Epilogue: Cleaning Up and Returning

                Line 20: leave
                Action: This single instruction performs two tasks:

                movq %rbp, %rsp: It sets the stack pointer to the address of the saved %rbp, effectively deallocating all local variables and the p array.

                popq %rbp: It pops the saved %rbp value from the stack into the %rbp register, restoring the caller's base pointer and moving %rsp to the saved return address.

                Line 21: ret
                Action: Pops the return address off the stack and jumps to it.
                Purpose: Returns control to the calling function.  

                // Visual Representation of the Stack

                Stack Bottom (Higher Addresses)
                +---------------------+
                |   Return address    |  <--- (Caller's frame starts here)
                +---------------------+
                |     Saved %rbp      |  <--- %rbp (Frame Pointer)
                +---------------------+
                |         i           |  <--- %rbp - 8
                +---------------------+
                |      (Unused)       |  <--- %rbp - 16
                +---------------------+
                |                     |
                |         p           |  (Variable-size array, 8n bytes)
                |                     |
                +---------------------+
                |                     |
                +---------------------+  <--- %rsp (Stack Pointer)
                Stack Top (Lower Addresses)                          
                




                                    





                                  



            
                    



            