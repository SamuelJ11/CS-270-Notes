CHAPTER 4: PROCESSOR ARCHITECTURE

    • The instructions supported by a particular processor and thier byte-level encodings are known as its instruction set architecture (ISA)

        - The ISA provides a conceptual layer of abstraction between compiler writers and processor designers

    • The ISA model would seem to imply seqential instruction execution, but in reality different parts of multiple instructions are executed 
      simultaneously, allowing the processor to achieve higher performance

        - exmaples including caching in web browsers, and information retrieval data structures such as a balanced binary tree and hash tables

    • This chapter defines a simple instruction set that we use as a running example for our processor implementations: the 'Y86-64' instructions set,
      modeled after the x86-64 instruction set.

        - has fewer data types, instructions, and addressing modes, with simple byte-level encodings that make it easier to design the CPU's decoding
          logic.

    • For this chapter we will assume the Y86-64 processor is based on sequential operation, executing one complete instruction once per clock cycle

        - with the sequential design as a basis, we then apply a series of transformations to create a 'pipelined' processor

            -- the processor breaks down the execution of each instruction into 5 steps, each of which is handled by a seperate section or 'stage' of
               the hardware

        - since each stage is handled by a seperate region of the hardware, the processor can execute the different steps of up to five instructions
          simultaneously

            -- this requires handling a variety of hazard conditions (location or operands of one instruction depend on those of another still in the 
               pipeline)

    I. The Y86-64 Instruction Set Architecture

        A. Programmer Visible state

            • In computer architecture, 'state' refers to all the information inside the processor and memory that determines what the computer will do next.

                - everything it “knows” right now that affects how it executes the next instruction.

            • The “programmer-visible state” is the part of the state that a programmer (or compiler) can directly read from or write to using instructions.

                - the state for Y86-64 is similar to that for x86-64. There are 15 program registers minus %r15 for simplicity.

                - There are three single-bit condition codes: ZF, SF, and OF

                - a final part of the program state is a status code Stat, indicating the overall state of program execution

        B. Y86-64 instructions

            • Only 8-byte integer operations for simplicity

                - xxmovq: immediate to register (im), register to memory (rm), register to register (rr), memory to register (mr)

                  -- the memory references for the two memory movement instructions have a simple base and displacement format (no scaling operations
                     supported)

                  -- instructions that move an immediate value to memory are NOT supported

                - OPq: addq, subq, andq, xorq ONLY ON REGISTER DATA and SET THE CONDITION CODES (ZF, SF, and OF)

                - jxx: jmp, jle, jl, je, jne, jge, and jg.

                - cmovexx:  cmovle, cmovl, cmove, cmovne, cmovge, and cmovg - these have the same format as the register–register move instruction rrmovq

                - push, pop, call and ret are the same

                - halt: stops instruction execution and sets status code to HLT

        C. Instruction encodings

            • Reference page 385 in the textbook to understand the notes below:

                - each instruction requires between 1 and 10 bytes

                - every instruction has an initial byte that identifies the instruction type and is divided into two 4-bit parts: the high-order (code)
                  part and the low-order (or function) part

                    --  the function values are only meaningful in cases where a group of related instructions share a common code

                  +----------------+---------+----------------+---------+----------------+---------+
                  |   Operations   |  Code   |    Branches    |  Code   |     Moves      |  Code   |
                  +----------------+---------+----------------+---------+----------------+---------+
                  | addq           | 6 0     | jmp            | 7 0     | rrmovq         | 2 0     |
                  | subq           | 6 1     | jle            | 7 1     | cmovle         | 2 1     |
                  | andq           | 6 2     | jl             | 7 2     | cmovl          | 2 2     |
                  | xorq           | 6 3     | je             | 7 3     | cmove          | 2 3     |
                  |                |         | jne            | 7 4     | cmovne         | 2 4     |
                  |                |         | jge            | 7 5     | cmovge         | 2 5     |
                  |                |         | jg             | 7 6     | cmovg          | 2 6     |
                  +----------------+---------+----------------+---------+----------------+---------+

                - each of the 15 program registers has an associated register identifier (ID) ranging from 0 to 0xE (see page 387)

                    -- the program registers are stored within the CPU in a register file, which is a small random-access memory where the register IDs serve as addresses

                    -- in the figure on page 395, instructions that have no register operands (branches, call, ret), do not include a register specifier byte, and
                       those that require only one register operand (irmovq, pushq, and popq) have the other register specifier set to value 0xF

                - some instructions require an additional 8-byte constant word, which can serve as the immediate data for irmovq, 
                  the displacement for rmmovq and mrmovq address specifiers, and the destination of branches and calls

                    -- branch and call instructions are given as absolute addresses for simplicity

                - all instructions are generated in little-endian 

                - example: generate the byte encoding of the instruction rmmovq %rsp,0x123456789abcd(%rdx) in hexadecimal

                    -- referencing figure 4.2 we see that:

                        rrmovq has the initial byte enocoding of '40'

                        register %rsp has the encoding '0x4'

                        register %rdx has the encoding '0x2'

                        immediate value in little endian padded to 8 bytes is: 0xcdab896745230100

                        byte encoding: 4042cdab896745230100

            • Every instruction has a unique combination of code and function in its initial byte, and given this byte, we can determine the length and meaning of
              any additional bytes. 
              
                - this property ensures that a processor can execute an objectcode program without any ambiguity about the meaning of the code

        D. Y86-64 Exceptions

            • Y86-64 exception codes are as follows:

                - 1: AOK Normal operation

                - 2: HLT halt instruction encountered

                - 3: ADR Invalid address encountered

                - 4: INS Invalid instruction encountered

            • For Y86-64, the processor stops executing instructions when it encounters any of the listed exceptions. 
            
                - in a more complete design, the processor would typically invoke an exception handler — a procedure designated to handle the specific 
                  type of exception encountered

        E. Y86-64 Programs

            • Given the restrictions placed on operations in Y86-64, lets take a look at how the assembly for the following C code is represented:

                long sum(long *start, long count) {
                long sum = 0;
                while (count) {
                    sum += *start;
                    start++;
                    count--;
                }
                return sum;
                }

                sum:
                  irmovq $8, %r8
                  irmovq $1, %r9
                  xorq %rax, %rax
                  andq %rsi, %rsi   //set the zero flag for the jne condition
                  jmp test
                loop:
                  mrmovq (%rdi), %r10
                  addq %r10, %rax
                  addq %r8, %rdi
                  subq %r9, %rsi
                test:
                  jne loop
                  ret

                * The Y86-64 code requires two instructions in 'loop' to read a value from memory and add it to a register

            • A full Y86-64 program is given below using the same function as before:

                1 #Execution begins at address 0
                2     .pos0
                3     irmovq stack, %rsp  #Setupstackpointer
                4     call main           #Execute main program
                5     halt                #Terminate program
                6
                7 #Array of 4 elements
                8     .align8
                9     array:
                10    .quad 0x000d000d000d
                11    .quad 0x00c000c000c0
                12    .quad 0x0b000b000b00
                13    .quad 0xa000a000a000
                14
                15 main:
                16    irmovq array,%rdi
                17    irmovq $4,%rsi
                18    call sum #sum(array,4)
                19    ret
                20
                21 #longsum(long *start, long count)
                22 #start in %rdi, count in %rsi
                23 sum:
                24    irmovq $8, %r8  #Constant 8
                25    irmovq $1, %r9  #Constant 1
                26    xorq %rax, %rax #sum = 0
                27    andq %rsi, %rsi #Set CC
                28    jmp test        
                29 loop:
                30    mrmovq(%rdi), %r10 
                31    addq %r10, %rax    
                32    addq %r8, %rdi 
                33    subq %r9, %rsi 
                34 test:
                35    jne loop #Stop when 0
                36    ret #Return
                37
                38 #Stack starts here and grows to lower addresses
                39    .pos 0x200
                40    stack:

                * code and data go at low addresses, and the stack starts higher and grows downward toward 0.
                * the assembler goes through the entire file before generating machine code - labels in assembly are resolved after the first pass
                * we must ensure that the stack does not grow so large that it overwrites the code or other program data.

                * because Y86-64 has no compiler, no linker, and no OS, you — the programmer — are responsible for:

                  - laying out memory (code, data, and stack)               
                  - initializing the stack pointer
                  - handling all function calls and returns
                  - ending the program explicitly with halt

                * see figure 4.8 on page 396 for the object file generated by the Y86-64 assembler (YAS)

        F. Some Y86-64 Instruction Details

            • The pushq instruction decreases the stack pointer by 8 and then writes a register value to memory. Therefore, it is not immediately clear what the 
              processor should do when executing pushq %rsp, since the instruction modifies the same register it is trying to push

                - There are two possible conventions:
                  (1) push the original value of %rsp, or       *this is what actually happens in X86-64
                  (2) push the decremented value of %rsp
 
                * the same is true for popq %rsp

    II. Logic Design and the Hardware Control Language HCL

            
