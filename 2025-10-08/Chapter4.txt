CHAPTER 4: PROCESSOR ARCHITECTURE

    • The instructions supported by a particular processor and thier byte-level encodings are known as its instruction set architecture (ISA)

        - The ISA provides a conceptual layer of abstraction between compiler writers and processor designers

    • The ISA model would seem to imply seqential instruction execution, but in reality different parts of multiple instructions are executed 
      simultaneously, allowing the processor to achieve higher performance

        - exmaples including caching in web browsers, and information retrieval data structures such as a balanced binary tree and hash tables

    • This chapter defines a simple instruction set that we use as a running example for our processor implementations: the 'Y86-64' instructions set,
      modeled after the x86-64 instruction set.

        - has fewer data types, instructions, and addressing modes, with simple byte-level encodings that make it easier to design the CPU's decoding
          logic.

    • For this chapter we will assume the Y86-64 processor is based on sequential operation, executing one complete instruction once per clock cycle

        - with the sequential design as a basis, we then apply a series of transformations to create a 'pipelined' processor

            -- the processor breaks down the execution of each instruction into 5 steps, each of which is handled by a seperate section or 'stage' of
               the hardware

        - since each stage is handled by a seperate region of the hardware, the processor can execute the different steps of up to five instructions
          simultaneously

            -- this requires handling a variety of hazard conditions (location or operands of one instruction depend on those of another still in the 
               pipeline)

    I. The Y86-64 Instruction Set Architecture

        A. Programmer Visible state

            • In computer architecture, 'state' refers to all the information inside the processor and memory that determines what the computer will do next.

                - everything it “knows” right now that affects how it executes the next instruction.

            • The “programmer-visible state” is the part of the state that a programmer (or compiler) can directly read from or write to using instructions.

                - the state for Y86-64 is similar to that for x86-64. There are 15 program registers minus %r15 for simplicity.

                - There are three single-bit condition codes: ZF, SF, and OF

                - a final part of the program state is a status code Stat, indicating the overall state of program execution

        B. Y86-64 instructions

            • Only 8-byte integer operations for simplicity

                - xxmovq: immediate to register (im), register to memory (rm), register to register (rr), memory to register (mr)

                  -- the memory references for the two memory movement instructions have a simple base and displacement format (no scaling operations
                     supported)

                - OPq: addq, subq, andq, xorq only on register data

                - jxx: jmp, jle, jl, je, jne, jge, and jg.

                - cmovexx:  cmovle, cmovl, cmove, cmovne, cmovge, and cmovg - these have the same format as the register–register move instruction rrmovq

                - push, pop, call and ret are the same

                - halt: stops instruction execution and sets status code to HLT

        C. Instruction encodings

            • Reference page 385 in the textbook to understand the notes below:

                - each instruction requires between 1 and 10 bytes

                - every instruction has an initial byte that identifies the instruction type and is divided into two 4-bit parts: the high-order (code)
                  part and the low-order (or function) part

                    --  the function values are only meaningful in cases where a group of related instructions share a common code

                  +----------------+---------+----------------+---------+----------------+---------+
                  |   Operations   |  Code   |    Branches    |  Code   |     Moves      |  Code   |
                  +----------------+---------+----------------+---------+----------------+---------+
                  | addq           | 6 0     | jmp            | 7 0     | rrmovq         | 2 0     |
                  | subq           | 6 1     | jle            | 7 1     | cmovle         | 2 1     |
                  | andq           | 6 2     | jl             | 7 2     | cmovl          | 2 2     |
                  | xorq           | 6 3     | je             | 7 3     | cmove          | 2 3     |
                  |                |         | jne            | 7 4     | cmovne         | 2 4     |
                  |                |         | jge            | 7 5     | cmovge         | 2 5     |
                  |                |         | jg             | 7 6     | cmovg          | 2 6     |
                  +----------------+---------+----------------+---------+----------------+---------+

                - each of the 15 program registers has an associated register identifier (ID) ranging from 0 to 0xE (see page 387)

                    -- the program registers are stored within the CPU in a register file, which is a small random-access memory where the register IDs serve as addresses

                    -- in the figure on page 395, instructions that have no register operands (branches, call, ret), do not include a register specifier byte, and
                       those that require only one register operand (irmovq, pushq, and popq) have the other register specifier set to value 0xF



