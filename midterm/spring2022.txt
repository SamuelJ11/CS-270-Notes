Problem 1:

    a. 15 & 24 = 00001111 & 00011000 = 00001000 = 8
    b. 27 ^ 7 = 00011011 ^ 00000111 = 00011111 = 31
    c. ((18 >> 2) | 3) = (00010010 >> 2) | 00000010 = 00000100 | 00000011 = 00000111 = 7

Problem 2:  For the following questions, assume a 13-bit word size (w = 13).

    a. What is the maximum positive signed integer value that can be stored in a word if two’s complement notation is used?

        • maximum positive signed integer value is 2^12 - 1     (0111111111111)
     
    b. What is the minimum signed (i.e., negative) integer value that can be represented in a word (two’s complement)?

        • minimum signed integer value is -2^12

    c. What is the maximum unsigned value that can be represented?

        • maximum unsigned integer value is 2^13 - 1

Problem 3:  Consider variables declared and added as follows:
            char a = -64;
            char b = ...;
            char x = a + b;

    a. Give an initial value of b that will cause the sum on the third line to overflow (pick b = -65 since minimum value for b is -64)

            • char holds 8 bits, and is signed by default
            • overflow occurs if (sign_a == sign_b) && (sign_result != sign_a) 

            a = 01000000 (+64) -> (negate all bits add 1) -> 10111111 + 1 = 11000000 (-64)
            b = 01000001 (+65) -> (negate all bits add 1) -> 10111110 + 1 = 10111111 (-65)

            x = 11000000
              + 10111111
            ____________  
               101111111 -> (disregard carry out bit) = 01111111 = (+127) overflow

Problem 4. For each of the following descriptions, circle the number of the
           single instruction that accomplishes that operation

    a. Copy 8 bytes from register %rdi to register %rax.

        • movq %rdi, %rax

    b. Multiply the contents of %rcx by 9, subtract 5, and put the result in %rax.

        • leaq -$5(%rcx, rcx, $8), %rax

    c. Add 16 to the contents of register %rbp, use the result as an address in memory, and
       load 8 bytes starting at that address into %rsi.

        • movq $16(%rbp), %rsi

    d. Copy 8 bytes from memory into %rdi, starting at the address in %rsp, and increase
       the value in %rsp by 8.
        
        • popq %rdi

Problem 5. Consider the following assembly code:
            leaq 8(%rdi,%rsi,4), %rsi
            shlq $2, %rdi
            leaq (%rdi,%rsi), %rax
            addq %rdx, %rax

            At the start of this code, the contents of the registers are as shown (as decimal integers)
            below. Fill in the blanks with the contents of the registers at the end of this code segment.
            You can use the middle row for intermediate calculations.

            • rsi = 52
            • rdi = 16
            • rax = 26
            • rax = 27

            +------------------+------+------+------+------+
            |                  | %rdi | %rsi | %rdx | %rax |
            +------------------+------+------+------+------+
            | initial contents |  4   |  10  |  1   | -1   |
            +------------------+------+------+------+------+
            | final contents   |  16  |  52  |  1   |  27  |
            +------------------+------+------+------+------+

Problem 6. Consider the code below:

            int pred(char *p) {
            while (*p)
            if (*p < 'A' || *p > 'Z')
                return 0;
            else
                p++;
            return 1;
            }

            • Checks that every character in the string has an ASCII value between 65 and 90
             *this effectively tests if the current character is not an uppercase English letter

            • char *s = "ABC"

Problem 7. Select the best answer:

    a. Which pair of instructions has the same effect as the single instruction pushq %rbx?

        (a) subq $8, %rsp     (b) subq $8, %rsp    (c) movq (%rbx), %rsp
            movq (%rsp), %rbx     movq %rbx, (%rsp)    movq %rsp, %rbx

            • (b)

    b. Space for array variables declared in the body of a function is allocated where?

            • (c) on the stack

    c. Which instruction involves a push instruction as a side effect?

            • (a) call

Problem 8. The body of a function foo of two arguments compiles (with -Og) into the following code:
            movq %rsi, %rax     // t = n
            testq %rsi, %rsi    // check if n == 0
            jne .L2
            movq %rdi, %rax     // t = m
            .L2:
            ret                 

        Which one of the following C function bodies is the one that generated the above code?
        *m = %rdi, n = %rsi, t = %rax

        (a) while (m > n)
            m -= n;
            return m;
        (b) if (m > n)
            t = m;
            else
            t = n;
            return t;
        (c) if (n == 0)
            t = m;
            else
            t = n;
            return t;

        • (c) is the correct choice

Problem 9.  Consider the following declaration of an array of structures:
            struct {
            char name[16];  // initial offset = 0
            long x;         // initial offset = 16
            short s;        // initial offset = 24
            } sa[10];       // final offset = 32

        For each of the following variables, give its offset in bytes from the first byte of the array 'sa'.

        * remember that the offset of any field f in element sa[i] from the beginning of the array sa is calculated as:

            offset = (i × size of structure) + internal offset of f

        a. sa[0].name[0]

            • offset = (0 x 32) + 0 = 0

        b. sa[0].name[5]

            • offset = (0 x 32) + 5 = 5

        c. sa[0].x

            • offset = (0 x 32) + 16 = 16

        d. sa[0].s

            • offset = (0 x 32) + 24 = 24

        e. sa[1]

            • offset = (1 x 32) = 32

        f. sa[2].x
        
            • offset = (2 x 32) + 16 = 80
        
      


            

