Problem 1:  this problem deals with 12-bit, 2’s complement signed integers.
For each pair of hexadecimal numbers below, circle the one that is greater.

    (a) 0xa27   0x731  
        • 0x731 is greater because its positive, while the other number is negative


    (b) 0x1a3   0x114
        • 0x1a3 is greater


    (c) 0xff2   0xf72
        • 0xff2 = 111111110010 -> (negate all bits add 1) = 000000001110 = -14
        • 0xf72 = 111101110010 -> (negate all bits add 1) = 000010001110 = -142

        •0xff2 is greater because it is less negative

Problem 2:

    (a) 65 | (1 << 5)
        • 1 << 5 = 32
        • 65 | 32 = 01000001 | 00100000 = 01100001
        • 01100001 = 97

    (b) 15 & -4
        • 00001111 & 11111100 = 00001100  
        • 00001100 = 12

    (c) 6 >> 2
        • 0110 -> 0001 = 1

    (d) 137 ^ 137
        • 0

Problem 3:  state answers in decimal. Assume 2’s complement representation

    (a) What is the maximum positive signed integer value that can be stored in a 10-bit
    word?
        • 2^9 - 1 = 511

    (b) What is the minimum signed (i.e., negative) integer value that can be represented in
    a 12-bit word?
        • -2^11 = -2048

Problem 4. Circle the correct answer

    a. Strings are represented as arrays of int in C. 
        • false
    b. The call instruction implicitly does a pop as well.
        • false
    c. In x86-64 Linux, the stack grows upward, i.e., from lower addresses to higher.
        • false
    d. Local variables (declared inside a function) are stored on the stack. 
        • true
    e. The state of a running process includes (among other things) the values contained in all    
    16 general-purpose registers, plus the current program counter. 
        • true
    f. The fork() system call creates an exact copy of a process, except for the process ID.    
        • we have not learned this and it will not be on the test

Problem 5. For each of the following instructions, circle the number of the
best description of the effect of the instruction.

    a. movq %rdi, (%rsp)
        • copy value in %rdi into memory starting at the address in %rsp

    b. leaq -5(%rcx,%rcx,4), %rax    
        • multiply the value in %rcx by 5, subtract 5, put the result in %rax  

    c. movq 16(%rbp), %rsi
        • none of the above

    d. callq foo
    
        • push the address of the next instruction and jump to the starting address of foo

Problem 6. Consider the following assembly code:
            leaq (%rdi,%rsi,4), %rsi
            shlq $3, %rdi
            leaq (%rdi,%rsi), %rax
            addq %rdx, %rax

            At the start of this code, the contents of the registers are as shown (as decimal integers)
            below. Fill in the blanks with the contents of the registers at the end of this code segment.
            You can use the middle row for intermediate calculations.

            • rsi = 33
            • rdi = 40
            • rax = 73
            • rax = 65

            +------------------+------+------+------+------+
            |                  | %rdi | %rsi | %rdx | %rax |
            +------------------+------+------+------+------+
            | initial contents |  5   |  7   |  -8  |  30  |
            +------------------+------+------+------+------+
            | final contents   |  40  |  33  |  -8  |  65  |
            +------------------+------+------+------+------+

Problem 7. Consider the following three-instruction sequence; numbers on
the left are the addresses of the instructions. Circle the number of the best answer.

    0x555555453e: pushq %rbx
    0x555555453f: callq <foo>
    0x5555554544: popq %rbx

    (a) What value is on the top of the stack when the first instruction of foo is executed?
        • 0x5555554544
    
    b. If %rsp contains the value x before these three instructions are executed, what does        
    %rsp contain after they are completed?
        • first two instructions decrement stack pointer, then the final instruction increments it
        • x − 8
        



      
    






        


